\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
    \usepackage{xltxtra,xunicode}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Mapping=tex-text,Scale=MatchLowercase}
  \newcommand{\euro}{â‚¬}
\fi
% use microtype if available
\IfFileExists{microtype.sty}{\usepackage{microtype}}{}
\usepackage[margin=1in]{geometry}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{{#1}}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{{#1}}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{{#1}}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{{#1}}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{{#1}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{{#1}}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{{#1}}}
\newcommand{\RegionMarkerTok}[1]{{#1}}
\newcommand{\ErrorTok}[1]{\textbf{{#1}}}
\newcommand{\NormalTok}[1]{{#1}}
\usepackage{graphicx}
% Redefine \includegraphics so that, unless explicit options are
% given, the image width will not exceed the width of the page.
% Images get their normal width if they fit onto the page, but
% are scaled down if they would overflow the margins.
\makeatletter
\def\ScaleIfNeeded{%
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother
\let\Oldincludegraphics\includegraphics
{%
 \catcode`\@=11\relax%
 \gdef\includegraphics{\@ifnextchar[{\Oldincludegraphics}{\Oldincludegraphics[width=\ScaleIfNeeded]}}%
}%
\ifxetex
  \usepackage[setpagesize=false, % page size defined by xetex
              unicode=false, % unicode breaks when used with xetex
              xetex]{hyperref}
\else
  \usepackage[unicode=true]{hyperref}
\fi
\hypersetup{breaklinks=true,
            bookmarks=true,
            pdfauthor={Colin Pistell},
            pdftitle={Understanding the Central Limit Theorem With Simulation},
            colorlinks=true,
            citecolor=blue,
            urlcolor=blue,
            linkcolor=magenta,
            pdfborder={0 0 0}}
\urlstyle{same}  % don't use monospace font for urls
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\setcounter{secnumdepth}{0}

%%% Change title format to be more compact
\usepackage{titling}
\setlength{\droptitle}{-2em}
  \title{Understanding the Central Limit Theorem With Simulation}
  \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
  \author{Colin Pistell}
  \preauthor{\centering\large\emph}
  \postauthor{\par}
  \predate{\centering\large\emph}
  \postdate{\par}
  \date{Friday, November 14, 2014}




\begin{document}

\maketitle


\subsubsection{Introduction:}\label{introduction}

Arguably, the most important concept in Statistics is the Central Limit
Theorem. It states that for any given population distribution with mean
= $\mu$ and standard deviation = $\sigma$, if we randomly select a
sufficiently sized sample (which we'll define as `n'), take its mean,
and then repeat that process a very large number of times (which we'll
define as `t'), we end up with a set of values that is normally
distributed around $\mu$ with a standard deviation of
$\frac{\sigma}{\sqrt{n}}$, which is known as the Standard Error.

Many people are very confused by the Central Limit Theorem (or CLT) when
they first learn about it. We hear language like ``standard deviation of
the sampling distribution of the sample mean'' and have trouble wrapping
our heads around it. We either give it up as a bad job or learn just
enough to plug numbers into formulas on math exams and accept vague
statements like ``your sample size should be at least 30'' without
digging deeper.

I personally find visualization to be very helpful when learning
something and I think visualizing the CLT can be particularly helpful.
To do this, we need to create a simulation. We definitely want to do
this with a computer because a computer can run thousands of trials in a
matter of moments and do all the heavy maths for us. We'll use R to
program the simulation and R's ggplot package to visualize the results.
I'll show all the code I'm using so you can follow along and I'll make
it available on github
\href{https://github.com/JCPistell/CLT-Simulation}{here.} I encourage
you to grab it and play with it yourself!

\subsubsection{Defining the Population:}\label{defining-the-population}

First thing's first: We need to make sure our R session is configured
correctly and set our random number seed so our results are
reproducible.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{require}\NormalTok{(ggplot2)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## Loading required package: ggplot2
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{set.seed}\NormalTok{(}\DecValTok{7759}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Now we need to create our population. Note that in the ``real world''
we'll never have perfect knowledge of the population we're studying, but
it'll be a huge help here because we can use it to see how well the CLT
works.

It's important to realize that the CLT will work for ANY population
distribution, no matter how wacky it is. To show this, let's test it
against a pretty weird population. Here's how we'll create it:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Create a non-uniform population of 100,000 numbers between 1 and 100}
\NormalTok{pop1 <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{20000}\NormalTok{, }\DataTypeTok{mean =} \DecValTok{10}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{3}\NormalTok{)}
\NormalTok{pop2 <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{80000}\NormalTok{, }\DataTypeTok{mean =} \DecValTok{70}\NormalTok{, }\DataTypeTok{sd =} \DecValTok{10}\NormalTok{)}
\NormalTok{pop <-}\StringTok{ }\KeywordTok{c}\NormalTok{(pop1, pop2)}

\NormalTok{mu <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(pop) }\CommentTok{#calculate the population mean}
\NormalTok{sigma <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(pop) }\CommentTok{#calculate the population standard deviation}
\KeywordTok{rm}\NormalTok{(pop1, pop2) }\CommentTok{#clean up}
\end{Highlighting}
\end{Shaded}

Let's take a look at what we've got:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{popdf <-}\StringTok{ }\KeywordTok{as.data.frame}\NormalTok{(pop)}
\NormalTok{hg <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(popdf, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \NormalTok{pop)) +}\StringTok{ }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"black"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"steelblue"}\NormalTok{) +}\StringTok{ }
\StringTok{        }\KeywordTok{ggtitle}\NormalTok{(}\StringTok{"Histogram of Population"}\NormalTok{) +}\StringTok{ }\KeywordTok{xlab}\NormalTok{(}\StringTok{"value"}\NormalTok{)}
\NormalTok{hg}
\end{Highlighting}
\end{Shaded}

\includegraphics{./CLT_mkdown_files/figure-latex/unnamed-chunk-3-1.pdf}

Excellent. Note that we've calculated our population mean $\mu = 58.01$
and our standard deviation $\sigma = 25.65$. We'll be referring back to
these later.

\subsubsection{The Simulation:}\label{the-simulation}

Time to run the simulation. In order to really see what's going on with
the CLT we're going to run this simulation a bunch of times with
different values for `n' (how many samples we take) and `t' (how many
trials we run). We'll store all this data in a table so we can then
visualize it. Note that this is almost certainly not the most efficient
way of coding this simulation, but I think it makes it pretty easy to
understand how it all works.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{n <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{100}\NormalTok{) }\CommentTok{#set up number of samples}
\NormalTok{t <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{100}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{10000}\NormalTok{) }\CommentTok{#set up number of trials in simulation}

\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{() }\CommentTok{#initialize our empty data frame}

\CommentTok{# Run the simulation}
\NormalTok{for(i in n) \{ }\CommentTok{#for each value of n...}
    \NormalTok{col <-}\StringTok{ }\KeywordTok{c}\NormalTok{()}
    \NormalTok{for(j in t) \{ }\CommentTok{#we loop through each value of t...}
        \NormalTok{trial <-}\StringTok{ }\DecValTok{1}\NormalTok{:j}
        \NormalTok{counter <-}\StringTok{ }\NormalTok{j }\CommentTok{#set up an egg timer based on whichever t value we're on}
        \NormalTok{value <-}\StringTok{ }\KeywordTok{c}\NormalTok{()}
        \NormalTok{while(counter >}\StringTok{ }\DecValTok{0}\NormalTok{) \{    }\CommentTok{# and extract n samples from the population...}
            \NormalTok{bucket <-}\StringTok{ }\KeywordTok{sample}\NormalTok{(pop, i, }\DataTypeTok{replace =} \OtherTok{TRUE}\NormalTok{)}
            \NormalTok{xbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(bucket) }\CommentTok{#calculate the mean...}
            \NormalTok{value <-}\StringTok{ }\KeywordTok{c}\NormalTok{(value, xbar) }\CommentTok{# and add it to a vector}
            \NormalTok{counter <-}\StringTok{ }\NormalTok{counter -}\StringTok{ }\DecValTok{1} \CommentTok{#egg timer counts down and loops back until it hits 0}
        \NormalTok{\}}
        \NormalTok{sbar <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(value) }\CommentTok{#calculate the standard deviation of our sample}
        \NormalTok{col <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(trial, value, sbar, i, j) }\CommentTok{#stick all the info together...}
        \NormalTok{df <-}\StringTok{ }\KeywordTok{rbind}\NormalTok{(df, col) }\CommentTok{#and attach it to our master data frame}
    \NormalTok{\} }\CommentTok{#and we do it again for the next set of values until we're done!}
    
\NormalTok{\}}

\KeywordTok{rm}\NormalTok{(col, bucket, value, counter, i, j, n, sbar, t, xbar, trial) }\CommentTok{#clean up}

\CommentTok{# Let's take a look!}
\KeywordTok{str}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## 'data.frame':    66660 obs. of  5 variables:
##  $ trial: num  1 2 3 4 5 6 7 8 9 10 ...
##  $ value: num  78.4 103.8 76.8 5.9 57.1 ...
##  $ sbar : num  30.5 30.5 30.5 30.5 30.5 ...
##  $ i    : num  1 1 1 1 1 1 1 1 1 1 ...
##  $ j    : num  10 10 10 10 10 10 10 10 10 10 ...
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(df, }\DataTypeTok{n =} \DecValTok{25}\NormalTok{) }\CommentTok{#the full table is too big to look at but we can take a peek at the first few rows.}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##    trial      value     sbar i   j
## 1      1  78.437079 30.48892 1  10
## 2      2 103.799899 30.48892 1  10
## 3      3  76.757030 30.48892 1  10
## 4      4   5.895178 30.48892 1  10
## 5      5  57.115890 30.48892 1  10
## 6      6  70.078027 30.48892 1  10
## 7      7  75.922762 30.48892 1  10
## 8      8  65.917111 30.48892 1  10
## 9      9  64.930066 30.48892 1  10
## 10    10  10.149737 30.48892 1  10
## 11     1  78.937776 25.46287 1 100
## 12     2  71.634467 25.46287 1 100
## 13     3  51.884210 25.46287 1 100
## 14     4  66.170830 25.46287 1 100
## 15     5  68.572041 25.46287 1 100
## 16     6  64.730679 25.46287 1 100
## 17     7  80.156125 25.46287 1 100
## 18     8  74.827322 25.46287 1 100
## 19     9  69.140215 25.46287 1 100
## 20    10  55.787072 25.46287 1 100
## 21    11  10.639685 25.46287 1 100
## 22    12  82.069167 25.46287 1 100
## 23    13  77.277233 25.46287 1 100
## 24    14  83.392655 25.46287 1 100
## 25    15  11.403050 25.46287 1 100
\end{verbatim}

Looking at the resulting data frame (which we've named `df') isn't very
exciting. But, now let's visualize the results and see what we can see:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# We tidy up our data frame to get it ready for graphing. Note that we built it in "tall"}
\CommentTok{# form so it's already structured for ggplot}

\KeywordTok{names}\NormalTok{(df) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"trial#"}\NormalTok{, }\StringTok{"value"}\NormalTok{, }\StringTok{"sdev"}\NormalTok{, }\StringTok{"samples"}\NormalTok{, }\StringTok{"trials"}\NormalTok{)}

\CommentTok{# Creating the plot}
\NormalTok{g <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(df, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \NormalTok{value)) +}\StringTok{ }\KeywordTok{geom_density}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"steelblue"}\NormalTok{) +}\StringTok{ }
\StringTok{        }\KeywordTok{facet_grid}\NormalTok{(samples ~}\StringTok{ }\NormalTok{trials, }\DataTypeTok{labeller =} \NormalTok{label_both) +}\StringTok{ }
\StringTok{        }\KeywordTok{ggtitle}\NormalTok{(}\StringTok{"Demonstrating The Central Limit Theorem With Simulation"}\NormalTok{) +}\StringTok{ }
\StringTok{        }\KeywordTok{geom_vline}\NormalTok{(}\DataTypeTok{xintercept =} \NormalTok{mu, }\DataTypeTok{linetype =} \StringTok{"dashed"}\NormalTok{)}
\NormalTok{g}
\end{Highlighting}
\end{Shaded}

\includegraphics{./CLT_mkdown_files/figure-latex/graph 1-1.pdf}

\subsubsection{Analysis:}\label{analysis}

Let's take some time to really digest what we're looking at here. Each
panel represents a simulation with different values of samples `n' and
trials `t'. For example, the top left panel shows the results for
pulling a sample size of 1 from the population, taking its mean (which
is just itself for n = 1), repeating the process a total of 10 times,
then plotting the resulting density function**. Now let's look at the
bottom right panel. Here we're pulling a sample size of 100 from the
population, taking its mean, repeating the process a total of 10,000
times, then plotting the density function.

**side note: we're using a density function rather than a histogram to
make the y-scales work better. If we used a histogram the scale
differences between t = 10 and t = 10,000 would result in many panels
appearing to be blank!

Remember that our population mean $\mu = 58.01$. If the CLT is true,
we'd expect to see our plotted density functions take on a normalized or
bell-curve-like shape centered around $\mu$. We've put a line down right
at $\mu$ on our graph so we can easily see that this appears to be
happening. Take a moment and think about whether increasing `n' or
increasing `t' has a greater effect on the shape and `tightness' of the
curve around $\mu$. Let's also notice that things really start looking
good when `n' is 30 or greater, which gives us some intuition around why
we ideally want sample sizes of 30 or greater.

What about the standard error? Remember that this is a shorthand way of
saying ``the standard deviation of the sample distribution of the sample
mean'', which doesn't exactly roll off the tongue. According to the CLT,
the standard error should equal $\frac{\sigma}{\sqrt{n}}$. This makes
sense if we think about it - as our sample size `n' increases, more of
our sample will be closer to the population mean $\mu$ and the resulting
distribution will be more tightly clumped around it. We can see this
happens by looking at our graph. But, how does the CLT's assertion that
the standard error is $\frac{\sigma}{\sqrt{n}}$ hold up to our observed
results?

Let's create a table of the 24 sample standard deviations (6 values of
`n' * 4 values of `t') we got from our simulation.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# create data frame of simulated sample standard deviations}
\NormalTok{m <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{unique}\NormalTok{(df$sdev), }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{6}\NormalTok{)}
\NormalTok{sdf <-}\StringTok{ }\KeywordTok{as.data.frame}\NormalTok{(m, }\DataTypeTok{row.names =} \KeywordTok{c}\NormalTok{(}\StringTok{"t10"}\NormalTok{, }\StringTok{"t100"}\NormalTok{, }\StringTok{"t1000"}\NormalTok{, }\StringTok{"t10000"}\NormalTok{))}
\KeywordTok{names}\NormalTok{(sdf) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"s1"}\NormalTok{, }\StringTok{"s5"}\NormalTok{, }\StringTok{"s10"}\NormalTok{, }\StringTok{"s30"}\NormalTok{, }\StringTok{"s50"}\NormalTok{, }\StringTok{"s100"}\NormalTok{)}
\NormalTok{sdf <-}\StringTok{ }\KeywordTok{t}\NormalTok{(sdf) }\CommentTok{#transposed to match our graph better}
\KeywordTok{rm}\NormalTok{(m) }\CommentTok{#clean up}
\NormalTok{sdf}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##            t10      t100     t1000    t10000
## s1   30.488919 25.462874 26.776761 25.453176
## s5   12.390729 11.109437 11.285796 11.520970
## s10   6.963056  8.270600  8.286171  8.182902
## s30   4.087005  4.313087  4.661867  4.676186
## s50   4.252869  3.806862  3.745439  3.592716
## s100  2.275072  2.734845  2.585293  2.573638
\end{verbatim}

Now let's calculate what the CLT tells us these values should be for
each value of `n'. We're using the standard error formula:

\[
se = \frac{\sigma}{\sqrt{n}}
\]

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Calculate our expected standard error from the population standard deviation}
\NormalTok{exvals <-}\StringTok{  }\NormalTok{sigma/}\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{30}\NormalTok{, }\DecValTok{50}\NormalTok{, }\DecValTok{100}\NormalTok{))}
\NormalTok{exvals}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 25.653426 11.472561  8.112326  4.683653  3.627942  2.565343
\end{verbatim}

Just eyeballing it, it looks like they're pretty close. A quick note
here: our `se' calculations are arranged horizontally, but we want to
compare them to each of the respective columns above. That's a bit
confusing, so we'll fix it in the next section. Let's calculate the
ratios of our observed values over the calculated standard error.
Realize that the closer the two values are, the closer $\frac{obs}{se}$
will be to 1.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Express how close we are as percentages.}
\NormalTok{pexval <-}\StringTok{ }\NormalTok{sdf/exvals}
\end{Highlighting}
\end{Shaded}

Finally, we'll subtract 1 from these values to calculate the distance
each observation is from the calculated standard error and round the
results to 3 decimal places to make it easier to read and interpret. If
$\frac{obs}{se} - 1 \approx 0$ then the simulation has provided evidence
that the standard error calculation is valid.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Subtract 1 to show distance from ideal and round to 3 decimals to make it readable}
\KeywordTok{round}\NormalTok{(pexval -}\StringTok{ }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##         t10   t100  t1000 t10000
## s1    0.188 -0.007  0.044 -0.008
## s5    0.080 -0.032 -0.016  0.004
## s10  -0.142  0.020  0.021  0.009
## s30  -0.127 -0.079 -0.005 -0.002
## s50   0.172  0.049  0.032 -0.010
## s100 -0.113  0.066  0.008  0.003
\end{verbatim}

Once `t' gets high enough, the values get very close to the CLT's
standard error calculation. We can see from this that if we ran a
simulation with an extremely high `t' value we'd get even closer.

\subsubsection{Conclusions:}\label{conclusions}

Through the power of simulation, we've visualized the Central Limit
Theorem in action and seen direct evidence that is is valid. Hopefully,
this demonstration has helped provide some insight into how the CLT
works. I encourage you to monkey around with the parameters, change the
`n', `t', and seed values and run some more experiments!

\end{document}
